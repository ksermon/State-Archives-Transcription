{% extends 'base.html' %}

{% block extra_css %}
  <link rel="stylesheet" href="{{ url_for('static', filename='styles/fileview.css') }}" />
{% endblock extra_css%}

{% block content %}
  <div class="main-box">
    <div class="page-header">
      <div>
        <h1 class="file-title">File: {{ name }}</h1>
        <p class="description">{{ description }}</p>
      </div>
      <div class="header-actions">
        <a class="btn" href="{{ url_for('main.download_transcription', file_id=file_id) }}">Download Text</a>
      </div>
    </div>

    <div class="viewer-editor">
      <div class="pdf-viewer">
        <div class="pdf-stage-wrapper">
          <div class="pdf-overlay">
            <div class="overlay-group zoom-controls">
              <button type="button" class="icon-btn" id="zoom-out" aria-label="Zoom out">&#8722;</button>
              <button type="button" class="icon-btn" id="zoom-in" aria-label="Zoom in">&#43;</button>
              <button type="button" class="icon-btn" id="reset-view" aria-label="Fit page">&#9974;</button>
            </div>
            <div class="overlay-group page-controls">
              <button type="button" id="prev-page" class="icon-btn{% if page <= 1 %} disabled{% endif %}" aria-label="Previous page" {% if page <= 1 %}disabled{% endif %}>&laquo;</button>
              <span class="page-indicator" id="page-indicator">{{ page }} / {{ total_pages }}</span>
              <button type="button" id="next-page" class="icon-btn{% if page >= total_pages %} disabled{% endif %}" aria-label="Next page" {% if page >= total_pages %}disabled{% endif %}>&raquo;</button>
            </div>
          </div>
          {% if image_dimensions %}
            {% set aspect = (image_dimensions.height / image_dimensions.width * 100) %}
          {% else %}
            {% set aspect = None %}
          {% endif %}
          <div id="pdf-stage" class="pdf-stage" {% if aspect %}style="--pdf-aspect: {{ '%.2f'|format(aspect) }}%;"{% endif %}>
            <img id="pdf-image" src="data:image/png;base64,{{ image }}" alt="Page image" />
            <div id="highlight-overlay" class="highlight-overlay"></div>
          </div>
        </div>
      </div>

      <div class="transcription-panel">
        <div class="panel-header">
          <h3>Transcription</h3>
          <button type="button" id="save-transcription" disabled>Save changes</button>
        </div>
        <p class="panel-subtitle">Double-click a line or use the pencil icon to edit. Click elsewhere to keep the change.</p>
        <div class="transcription-helper">
          <div id="transcription-lines" class="transcription-lines"></div>
        </div>
        <textarea id="transcription-editor" spellcheck="false" hidden>{{ transcription }}</textarea>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@panzoom/panzoom@4.5.1/dist/panzoom.min.js" integrity="sha256-9PI4Hcqdhk6UDuIArOUvzRL9S/uJRmDpkA2o4gIigDs=" crossorigin="anonymous"></script>
  <script>
    const rawLineBoxes = {{ line_boxes | tojson }};
    const fileId = {{ file_id }};
    let currentPageNumber = {{ page }};
    let totalPages = {{ total_pages }};

    const pdfStage = document.getElementById('pdf-stage');
    const pdfWrapper = pdfStage.parentElement;
    const pdfImage = document.getElementById('pdf-image');
    const highlightOverlay = document.getElementById('highlight-overlay');
    const transcriptionEditor = document.getElementById('transcription-editor');
    const saveButton = document.getElementById('save-transcription');
    const transcriptionLinesContainer = document.getElementById('transcription-lines');
    const prevButton = document.getElementById('prev-page');
    const nextButton = document.getElementById('next-page');
    const pageIndicator = document.getElementById('page-indicator');

    const panzoomInstance = Panzoom(pdfStage, {
      contain: 'outside',
      maxScale: 5,
      minScale: 0.5,
      cursor: 'grab'
    });

    pdfWrapper.addEventListener('wheel', panzoomInstance.zoomWithWheel);

    document.getElementById('zoom-in').addEventListener('click', () => panzoomInstance.zoomIn());
    document.getElementById('zoom-out').addEventListener('click', () => panzoomInstance.zoomOut());
    document.getElementById('reset-view').addEventListener('click', () => panzoomInstance.reset());

    function prepareLineBoxes(rawBoxes, lineCount) {
      const boxes = Array.isArray(rawBoxes) ? rawBoxes.slice(0, lineCount) : [];
      while (boxes.length < lineCount) {
        boxes.push(null);
      }
      return boxes;
    }

    function getImageDataUrl(imagePayload) {
      if (!imagePayload) {
        return null;
      }
      if (typeof imagePayload === 'string') {
        return imagePayload.startsWith('data:')
          ? imagePayload
          : `data:image/png;base64,${imagePayload}`;
      }
      const base64 = imagePayload.data_url || imagePayload.data || imagePayload.base64;
      if (!base64) {
        return null;
      }
      if (typeof base64 === 'string' && base64.startsWith('data:')) {
        return base64;
      }
      const mime = imagePayload.content_type || imagePayload.mime_type || 'image/png';
      return `data:${mime};base64,${base64}`;
    }

    function setButtonDisabled(button, disabled) {
      if (!button) {
        return;
      }
      button.disabled = disabled;
      if (disabled) {
        button.classList.add('disabled');
      } else {
        button.classList.remove('disabled');
      }
    }

    function updateNavigationUI(page, total) {
      if (pageIndicator) {
        pageIndicator.textContent = `${page} / ${total}`;
      }
      setButtonDisabled(prevButton, page <= 1);
      setButtonDisabled(nextButton, page >= total);
    }

    let lines = transcriptionEditor.value.length ? transcriptionEditor.value.split('\n') : [''];
    lines = lines.map((line) => line.replace(/\r/g, ''));
    let lineBoxes = prepareLineBoxes(rawLineBoxes, lines.length);
    let overlayRects = [];
    let activeLineIndex = null;
    let activeLineEl = null;
    let activeEditor = null;
    let isDirty = false;
    let isLoadingPage = false;

    function updateHiddenTranscription() {
      transcriptionEditor.value = lines.join('\n');
    }

    function setLineActions(lineEl) {
      const actions = lineEl.querySelector('.line-actions');
      actions.innerHTML = '';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'icon-btn line-edit-btn';
      editBtn.setAttribute('aria-label', 'Edit line');
      editBtn.innerHTML = '&#9998;';
      actions.appendChild(editBtn);
      lineEl.classList.remove('editing');
    }

    function applyLineText(lineEl, text) {
      const textEl = lineEl.querySelector('.line-text');
      const cleanText = text.replace(/\r/g, '');
      if (!cleanText.length) {
        textEl.textContent = '(blank line)';
        textEl.classList.add('is-empty');
        lineEl.classList.add('is-empty');
      } else {
        textEl.textContent = cleanText;
        textEl.classList.remove('is-empty');
        lineEl.classList.remove('is-empty');
      }
    }

    function renderLines() {
      transcriptionLinesContainer.innerHTML = '';
      lines.forEach((text, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'transcription-line';
        lineEl.dataset.lineIndex = index;

        const numberEl = document.createElement('span');
        numberEl.className = 'line-number';
        numberEl.textContent = String(index + 1);

        const mainEl = document.createElement('div');
        mainEl.className = 'line-main';

        const textEl = document.createElement('div');
        textEl.className = 'line-text';
        mainEl.appendChild(textEl);

        const actionsEl = document.createElement('div');
        actionsEl.className = 'line-actions';
        mainEl.appendChild(actionsEl);

        lineEl.appendChild(numberEl);
        lineEl.appendChild(mainEl);

        transcriptionLinesContainer.appendChild(lineEl);
        applyLineText(lineEl, text);
        setLineActions(lineEl);
      });
    }

    function buildOverlay() {
      highlightOverlay.innerHTML = '';
      overlayRects = new Array(lineBoxes.length).fill(null);
      lineBoxes.forEach((box, index) => {
        if (!box) {
          return;
        }
        const rect = document.createElement('div');
        rect.className = 'line-region';
        rect.dataset.lineIndex = index;
        rect.style.left = `${box.x * 100}%`;
        rect.style.top = `${box.y * 100}%`;
        rect.style.width = `${box.width * 100}%`;
        rect.style.height = `${box.height * 100}%`;
        highlightOverlay.appendChild(rect);
        overlayRects[index] = rect;
      });
    }

    function highlightLine(index) {
      if (index === null || Number.isNaN(index)) {
        return;
      }
      if (activeEditor && activeEditor.index !== index) {
        closeEditor(activeEditor, { commit: true });
      }
      if (activeLineEl) {
        activeLineEl.classList.remove('active');
      }
      overlayRects.forEach((rect) => {
        if (rect) {
          rect.classList.remove('active');
        }
      });
      const nextLine = transcriptionLinesContainer.querySelector(`[data-line-index="${index}"]`);
      if (!nextLine) {
        activeLineEl = null;
        activeLineIndex = null;
        return;
      }
      nextLine.classList.add('active');
      const overlay = overlayRects[index];
      if (overlay) {
        overlay.classList.add('active');
      }
      nextLine.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      activeLineEl = nextLine;
      activeLineIndex = index;
    }

    function markDirty() {
      if (isDirty) {
        return;
      }
      isDirty = true;
      saveButton.disabled = false;
      saveButton.textContent = 'Save changes';
      saveButton.classList.add('has-changes');
    }

    function resetDirtyState() {
      isDirty = false;
      saveButton.disabled = true;
      saveButton.textContent = 'Save changes';
      saveButton.classList.remove('has-changes');
    }

    function closeEditor(editor, { commit }) {
      if (!editor) {
        return;
      }
      const { lineEl, index, textarea, original } = editor;
      const nextValue = commit ? textarea.value : original;
      const normalizedValue = nextValue.replace(/\r/g, '');
      const changed = commit && normalizedValue !== original;
      lines[index] = normalizedValue;
      applyLineText(lineEl, normalizedValue);
      setLineActions(lineEl);
      lineEl.classList.remove('editing');
      delete lineEl.dataset.editing;
      activeEditor = null;
      updateHiddenTranscription();
      if (changed) {
        markDirty();
      }
    }

    function openEditor(lineEl, index) {
      if (lineEl.dataset.editing === 'true') {
        return;
      }
      if (activeEditor) {
        closeEditor(activeEditor, { commit: true });
      }
      const textEl = lineEl.querySelector('.line-text');
      const originalText = lines[index] ?? '';
      const textarea = document.createElement('textarea');
      textarea.className = 'line-editor';
      textarea.value = originalText;
      textEl.classList.remove('is-empty');
      textEl.innerHTML = '';
      textEl.appendChild(textarea);

      const actions = lineEl.querySelector('.line-actions');
      actions.innerHTML = '';
      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';
      saveBtn.className = 'icon-btn line-commit-btn';
      saveBtn.setAttribute('aria-label', 'Save line');
      saveBtn.innerHTML = '&#10003;';
      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.className = 'icon-btn line-cancel-btn';
      cancelBtn.setAttribute('aria-label', 'Undo edit');
      cancelBtn.innerHTML = '&#10005;';
      actions.appendChild(saveBtn);
      actions.appendChild(cancelBtn);

      lineEl.dataset.editing = 'true';
      lineEl.classList.add('editing');
      activeEditor = { lineEl, index, textarea, original: originalText };

      requestAnimationFrame(() => {
        textarea.focus();
        textarea.select();
      });

      textarea.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && (event.metaKey || event.ctrlKey)) {
          event.preventDefault();
          closeEditor(activeEditor, { commit: true });
        }
      });

      textarea.addEventListener('blur', () => {
        setTimeout(() => {
          if (activeEditor && activeEditor.textarea === textarea) {
            closeEditor(activeEditor, { commit: true });
          }
        }, 10);
      });
    }

    function clearActiveLine() {
      if (activeLineEl) {
        activeLineEl.classList.remove('active');
      }
      overlayRects.forEach((rect) => rect && rect.classList.remove('active'));
      activeLineEl = null;
      activeLineIndex = null;
    }

    transcriptionLinesContainer.addEventListener('click', (event) => {
      const commitBtn = event.target.closest('.line-commit-btn');
      if (commitBtn && activeEditor) {
        event.stopPropagation();
        event.preventDefault();
        closeEditor(activeEditor, { commit: true });
        return;
      }

      const cancelBtn = event.target.closest('.line-cancel-btn');
      if (cancelBtn && activeEditor) {
        event.stopPropagation();
        event.preventDefault();
        closeEditor(activeEditor, { commit: false });
        return;
      }

      const lineEl = event.target.closest('.transcription-line');
      if (!lineEl) {
        if (activeEditor) {
          closeEditor(activeEditor, { commit: true });
        }
        clearActiveLine();
        return;
      }

      const index = parseInt(lineEl.dataset.lineIndex, 10);
      highlightLine(index);

      if (event.target.closest('.line-edit-btn')) {
        event.preventDefault();
        openEditor(lineEl, index);
      }
    });

    transcriptionLinesContainer.addEventListener('dblclick', (event) => {
      const lineEl = event.target.closest('.transcription-line');
      if (!lineEl) {
        return;
      }
      const index = parseInt(lineEl.dataset.lineIndex, 10);
      highlightLine(index);
      openEditor(lineEl, index);
    });

    transcriptionLinesContainer.addEventListener('mouseover', (event) => {
      const lineEl = event.target.closest('.transcription-line');
      if (!lineEl) {
        overlayRects.forEach((rect) => rect && rect.classList.remove('hover'));
        return;
      }
      const index = parseInt(lineEl.dataset.lineIndex, 10);
      overlayRects.forEach((rect, rectIndex) => {
        if (!rect) {
          return;
        }
        if (rectIndex === index) {
          rect.classList.add('hover');
        } else {
          rect.classList.remove('hover');
        }
      });
    });

    transcriptionLinesContainer.addEventListener('mouseleave', () => {
      overlayRects.forEach((rect) => rect && rect.classList.remove('hover'));
    });

    document.addEventListener('click', (event) => {
      if (!activeEditor) {
        return;
      }
      if (event.target.closest('.transcription-line')) {
        return;
      }
      closeEditor(activeEditor, { commit: true });
    });

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && activeEditor) {
        event.preventDefault();
        closeEditor(activeEditor, { commit: false });
      }
    });

    saveButton.addEventListener('click', async () => {
      if (activeEditor) {
        closeEditor(activeEditor, { commit: true });
      }
      if (!isDirty) {
        return;
      }
      saveButton.disabled = true;
      saveButton.textContent = 'Saving...';
      saveButton.classList.remove('has-changes');
      try {
        const response = await fetch(`/api/files/${fileId}/pages/${currentPageNumber}/transcription`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ transcription: lines.join('\n') })
        });
        if (!response.ok) {
          throw new Error('Failed to save transcription');
        }
        saveButton.textContent = 'Saved';
        setTimeout(() => {
          if (!isDirty) {
            saveButton.textContent = 'Save changes';
          }
        }, 2000);
        resetDirtyState();
      } catch (error) {
        console.error(error);
        saveButton.disabled = false;
        saveButton.textContent = 'Retry save';
        saveButton.classList.add('has-changes');
      }
    });

    async function loadPage(targetPage) {
      if (isLoadingPage || targetPage === currentPageNumber) {
        return;
      }
      if (targetPage < 1 || targetPage > totalPages) {
        return;
      }
      isLoadingPage = true;
      setButtonDisabled(prevButton, true);
      setButtonDisabled(nextButton, true);
      try {
        const response = await fetch(`/api/files/${fileId}/pages/${targetPage}`);
        if (!response.ok) {
          throw new Error(`Failed to load page ${targetPage}`);
        }
        const data = await response.json();
        applyPageData(data);
      } catch (error) {
        console.error(error);
        updateNavigationUI(currentPageNumber, totalPages);
      } finally {
        isLoadingPage = false;
        updateNavigationUI(currentPageNumber, totalPages);
      }
    }

    function applyPageData(data) {
      if (!data || typeof data !== 'object') {
        return;
      }
      if (activeEditor) {
        closeEditor(activeEditor, { commit: false });
      }
      const transcription = typeof data.transcription === 'string' ? data.transcription : '';
      const nextLines = Array.isArray(data.transcription_lines) && data.transcription_lines.length
        ? data.transcription_lines.slice()
        : (transcription.length ? transcription.split('\n') : ['']);
      lines = nextLines.length ? nextLines.map((line) => line.replace(/\r/g, '')) : [''];
      lineBoxes = prepareLineBoxes(data.line_boxes, lines.length);
      transcriptionEditor.value = lines.join('\n');
      renderLines();
      buildOverlay();
      clearActiveLine();
      updateHiddenTranscription();
      resetDirtyState();

      const imageUrl = getImageDataUrl(data.image);
      if (imageUrl) {
        pdfImage.src = imageUrl;
      }

      if (data.dimensions && data.dimensions.width && data.dimensions.height) {
        const aspectPercent = (data.dimensions.height / data.dimensions.width) * 100;
        pdfStage.style.setProperty('--pdf-aspect', `${aspectPercent.toFixed(2)}%`);
      } else {
        pdfStage.style.removeProperty('--pdf-aspect');
      }

      if (typeof data.page === 'number') {
        currentPageNumber = data.page;
      }
      if (typeof data.total_pages === 'number') {
        totalPages = data.total_pages;
      }

      panzoomInstance.reset();
      updateNavigationUI(currentPageNumber, totalPages);
    }

    if (prevButton) {
      prevButton.addEventListener('click', () => {
        if (isLoadingPage || currentPageNumber <= 1) {
          return;
        }
        loadPage(currentPageNumber - 1);
      });
    }

    if (nextButton) {
      nextButton.addEventListener('click', () => {
        if (isLoadingPage || currentPageNumber >= totalPages) {
          return;
        }
        loadPage(currentPageNumber + 1);
      });
    }

    renderLines();
    buildOverlay();
    updateHiddenTranscription();
    resetDirtyState();
    updateNavigationUI(currentPageNumber, totalPages);
  </script>
{% endblock %}
